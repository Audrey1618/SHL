{
  "script": "return (function querySelectorAllDeep(findMany, s, r) {\n    function normalizeSelector(sel) {\n        // save unmatched text, if any\n        function saveUnmatched() {\n            if (unmatched) {\n                // whitespace needed after combinator?\n                if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {\n                    tokens.push(' ');\n                }\n                // save unmatched text\n                tokens.push(unmatched);\n            }\n        }\n        const tokens = [], state = [0], not_escaped_pattern = /(?:[^\\\\]|(?:^|[^\\\\])(?:\\\\\\\\)+)$/, whitespace_pattern = /^\\s+$/, state_patterns = [\n            /\\s+|\\/\\*|[\"'>~+[(]/g, // general\n            /\\s+|\\/\\*|[\"'[\\]()]/g, // [..] set\n            /\\s+|\\/\\*|[\"'[\\]()]/g, // (..) set\n            null, // string literal (placeholder)\n            /\\*\\//g, // comment\n        ];\n        let match, unmatched, regex, next_match_idx = 0, prev_match_idx;\n        sel = sel.trim();\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            unmatched = '';\n            regex = state_patterns[state[state.length - 1]];\n            regex.lastIndex = next_match_idx;\n            match = regex.exec(sel);\n            // matched text to process?\n            if (match) {\n                prev_match_idx = next_match_idx;\n                next_match_idx = regex.lastIndex;\n                // collect the previous string chunk not matched before this token\n                if (prev_match_idx < next_match_idx - match[0].length) {\n                    unmatched = sel.substring(prev_match_idx, next_match_idx - match[0].length);\n                }\n                // general, [ ] pair, ( ) pair?\n                if (state[state.length - 1] < 3) {\n                    saveUnmatched();\n                    // starting a [ ] pair?\n                    if (match[0] === '[') {\n                        state.push(1);\n                    }\n                    // starting a ( ) pair?\n                    else if (match[0] === '(') {\n                        state.push(2);\n                    }\n                    // starting a string literal?\n                    else if (/^[\"']$/.test(match[0])) {\n                        state.push(3);\n                        state_patterns[3] = new RegExp(match[0], 'g');\n                    }\n                    // starting a comment?\n                    else if (match[0] === '/*') {\n                        state.push(4);\n                    }\n                    // ending a [ ] or ( ) pair?\n                    else if (/^[\\])]$/.test(match[0]) && state.length > 0) {\n                        state.pop();\n                    }\n                    // handling whitespace or a combinator?\n                    else if (/^(?:\\s+|[~+>])$/.test(match[0])) {\n                        // need to insert whitespace before?\n                        if (tokens.length > 0 &&\n                            !whitespace_pattern.test(tokens[tokens.length - 1]) &&\n                            state[state.length - 1] === 0) {\n                            // add normalized whitespace\n                            tokens.push(' ');\n                        }\n                        // case-insensitive attribute selector CSS L4\n                        if (state[state.length - 1] === 1 &&\n                            tokens.length === 5 &&\n                            tokens[2].charAt(tokens[2].length - 1) === '=') {\n                            tokens[4] = ' ' + tokens[4];\n                        }\n                        // whitespace token we can skip?\n                        if (whitespace_pattern.test(match[0])) {\n                            continue;\n                        }\n                    }\n                    // save matched text\n                    tokens.push(match[0]);\n                }\n                // otherwise, string literal or comment\n                else {\n                    // save unmatched text\n                    tokens[tokens.length - 1] += unmatched;\n                    // unescaped terminator to string literal or comment?\n                    if (not_escaped_pattern.test(tokens[tokens.length - 1])) {\n                        // comment terminator?\n                        if (state[state.length - 1] === 4) {\n                            // ok to drop comment?\n                            if (tokens.length < 2 ||\n                                whitespace_pattern.test(tokens[tokens.length - 2])) {\n                                tokens.pop();\n                            }\n                            // otherwise, turn comment into whitespace\n                            else {\n                                tokens[tokens.length - 1] = ' ';\n                            }\n                            // handled already\n                            match[0] = '';\n                        }\n                        state.pop();\n                    }\n                    // append matched text to existing token\n                    tokens[tokens.length - 1] += match[0];\n                }\n            }\n            // otherwise, end of processing (no more matches)\n            else {\n                unmatched = sel.substr(next_match_idx);\n                saveUnmatched();\n                break;\n            }\n        }\n        return tokens.join('').trim();\n    }\n    function _querySelectorDeep(selector, root, allElements = null) {\n        selector = normalizeSelector(selector);\n        const lightElement = root.querySelector(selector);\n        // @ts-expect-error createShadowRoot does not exist in head\n        if (document.head.createShadowRoot || document.head.attachShadow) {\n            // no need to do any special if selector matches something specific in light-dom\n            if (!findMany && lightElement) {\n                return lightElement;\n            }\n            // split on commas because those are a logical divide in the operation\n            const selectionsToMake = splitByCharacterUnlessQuoted(selector, ',');\n            return selectionsToMake.reduce((acc, minimalSelector) => {\n                // if not finding many just reduce the first match\n                if (!findMany && acc) {\n                    return acc;\n                }\n                // do best to support complex selectors and split the query\n                const splitSelector = splitByCharacterUnlessQuoted(minimalSelector\n                    //remove white space at start of selector\n                    .replace(/^\\s+/g, '')\n                    .replace(/\\s*([>+~]+)\\s*/g, '$1'), ' ')\n                    // filter out entry white selectors\n                    .filter((entry) => !!entry)\n                    // convert \"a > b\" to [\"a\", \"b\"]\n                    .map((entry) => splitByCharacterUnlessQuoted(entry, '>'));\n                const possibleElementsIndex = splitSelector.length - 1;\n                const lastSplitPart = splitSelector[possibleElementsIndex][splitSelector[possibleElementsIndex].length - 1];\n                const possibleElements = collectAllElementsDeep(lastSplitPart, root, allElements);\n                const findElements = findMatchingElement(splitSelector, possibleElementsIndex, root);\n                if (findMany) {\n                    acc = acc.concat(possibleElements.filter(findElements));\n                    return acc;\n                }\n                acc = possibleElements.find(findElements);\n                return acc || null;\n            }, findMany ? [] : null);\n        }\n        return !findMany\n            ? lightElement\n            : root.querySelectorAll(selector);\n    }\n    function findMatchingElement(splitSelector, possibleElementsIndex, root) {\n        return (element) => {\n            let position = possibleElementsIndex;\n            let parent = element;\n            let foundElement = false;\n            while (parent && !isDocumentNode(parent)) {\n                let foundMatch = true;\n                if (splitSelector[position].length === 1) {\n                    foundMatch = parent.matches(splitSelector[position]);\n                }\n                else {\n                    // selector is in the format \"a > b\"\n                    // make sure a few parents match in order\n                    const reversedParts = ([]).concat(splitSelector[position]).reverse();\n                    let newParent = parent;\n                    for (const part of reversedParts) {\n                        if (!newParent || !newParent.matches(part)) {\n                            foundMatch = false;\n                            break;\n                        }\n                        newParent = findParentOrHost(newParent, root);\n                    }\n                }\n                if (foundMatch && position === 0) {\n                    foundElement = true;\n                    break;\n                }\n                if (foundMatch) {\n                    position--;\n                }\n                parent = findParentOrHost(parent, root);\n            }\n            return foundElement;\n        };\n    }\n    function splitByCharacterUnlessQuoted(selector, character) {\n        return selector.match(/\\\\?.|^$/g).reduce((p, c) => {\n            if (c === '\"' && !p.sQuote) {\n                p.quote ^= 1;\n                p.a[p.a.length - 1] += c;\n            }\n            else if (c === '\\'' && !p.quote) {\n                p.sQuote ^= 1;\n                p.a[p.a.length - 1] += c;\n            }\n            else if (!p.quote && !p.sQuote && c === character) {\n                p.a.push('');\n            }\n            else {\n                p.a[p.a.length - 1] += c;\n            }\n            return p;\n        }, { a: [''] }).a;\n    }\n    /**\n     * Checks if the node is a document node or not.\n     * @param {Node} node\n     * @returns {node is Document | DocumentFragment}\n     */\n    function isDocumentNode(node) {\n        return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_NODE;\n    }\n    function findParentOrHost(element, root) {\n        const parentNode = element.parentNode;\n        // @ts-expect-error\n        return (parentNode && parentNode.host && parentNode.nodeType === 11)\n            // @ts-expect-error\n            ? parentNode.host\n            : parentNode === root\n                ? null\n                : parentNode;\n    }\n    /**\n     * Finds all elements on the page, inclusive of those within shadow roots.\n     * @param {string=} selector Simple selector to filter the elements by. e.g. 'a', 'div.main'\n     * @return {!Array<string>} List of anchor hrefs.\n     * @author ebidel@ (Eric Bidelman)\n     * License Apache-2.0\n     */\n    function collectAllElementsDeep(selector = null, root, cachedElements = null) {\n        let allElements = [];\n        if (cachedElements) {\n            allElements = cachedElements;\n        }\n        else {\n            const findAllElements = function (nodes) {\n                for (let i = 0; i < nodes.length; i++) {\n                    const el = nodes[i];\n                    allElements.push(el);\n                    // If the element has a shadow root, dig deeper.\n                    if (el.shadowRoot) {\n                        findAllElements(el.shadowRoot.querySelectorAll('*'));\n                    }\n                }\n            };\n            if (root.shadowRoot) {\n                findAllElements(root.shadowRoot?.querySelectorAll('*'));\n            }\n            findAllElements(root.querySelectorAll('*'));\n        }\n        return selector ? allElements.filter(el => el.matches(selector)) : allElements;\n    }\n    return _querySelectorDeep(s, r || document);\n}).apply(null, arguments)",
  "args": [
    true,
    "[data-testid=\"propertyPrice\"]",
    null
  ]
}